{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pool_config_1 = __importDefault(require(\"./pool-config\"));\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar Logger = neo4j_driver_core_1.internal.logger.Logger;\n\nvar Pool =\n/** @class */\nfunction () {\n  /**\n   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n   *                an allocation function that creates a promise with a new resource. It's given an address for which to\n   *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n   * @param {function(resource: object): Promise<void>} destroy\n   *                called with the resource when it is evicted from this pool\n   * @param {function(resource: object): boolean} validate\n   *                called at various times (like when an instance is acquired and when it is returned.\n   *                If this returns false, the resource will be evicted\n   * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n   *                called when the resource is released back to pool\n   * @param {function(resource: object): void} removeIdleObserver\n   *                called when the resource is acquired from the pool\n   * @param {PoolConfig} config configuration for the new driver.\n   * @param {Logger} log the driver logger.\n   */\n  function Pool(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.create,\n        create = _c === void 0 ? function (address, release) {\n      return Promise.resolve();\n    } : _c,\n        _d = _b.destroy,\n        destroy = _d === void 0 ? function (conn) {\n      return Promise.resolve();\n    } : _d,\n        _e = _b.validate,\n        validate = _e === void 0 ? function (conn) {\n      return true;\n    } : _e,\n        _f = _b.installIdleObserver,\n        installIdleObserver = _f === void 0 ? function (conn, observer) {} : _f,\n        _g = _b.removeIdleObserver,\n        removeIdleObserver = _g === void 0 ? function (conn) {} : _g,\n        _h = _b.config,\n        config = _h === void 0 ? pool_config_1.default.defaultConfig() : _h,\n        _j = _b.log,\n        log = _j === void 0 ? Logger.noOp() : _j;\n\n    this._create = create;\n    this._destroy = destroy;\n    this._validate = validate;\n    this._installIdleObserver = installIdleObserver;\n    this._removeIdleObserver = removeIdleObserver;\n    this._maxSize = config.maxSize;\n    this._acquisitionTimeout = config.acquisitionTimeout;\n    this._pools = {};\n    this._pendingCreates = {};\n    this._acquireRequests = {};\n    this._activeResourceCounts = {};\n    this._release = this._release.bind(this);\n    this._log = log;\n    this._closed = false;\n  }\n  /**\n   * Acquire and idle resource fom the pool or create a new one.\n   * @param {ServerAddress} address the address for which we're acquiring.\n   * @return {Object} resource that is ready to use.\n   */\n\n\n  Pool.prototype.acquire = function (address) {\n    var _this = this;\n\n    return this._acquire(address).then(function (resource) {\n      var key = address.asKey();\n\n      if (resource) {\n        // New or existing resource acquired\n        return resource;\n      } // We're out of resources and will try to acquire later on when an existing resource is released.\n\n\n      var allRequests = _this._acquireRequests;\n      var requests = allRequests[key];\n\n      if (!requests) {\n        allRequests[key] = [];\n      }\n\n      return new Promise(function (resolve, reject) {\n        var request;\n        var timeoutId = setTimeout(function () {\n          // acquisition timeout fired\n          // remove request from the queue of pending requests, if it's still there\n          // request might've been taken out by the release operation\n          var pendingRequests = allRequests[key];\n\n          if (pendingRequests) {\n            allRequests[key] = pendingRequests.filter(function (item) {\n              return item !== request;\n            });\n          }\n\n          if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do\n          } else {\n            // request is still pending and needs to be failed\n            var activeCount = _this.activeResourceCount(address);\n\n            var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n            request.reject(neo4j_driver_core_1.newError(\"Connection acquisition timed out in \" + _this._acquisitionTimeout + \" ms. Poos status: Active conn count = \" + activeCount + \", Idle conn count = \" + idleCount + \".\"));\n          }\n        }, _this._acquisitionTimeout);\n        request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n        allRequests[key].push(request);\n      });\n    });\n  };\n  /**\n   * Destroy all idle resources for the given address.\n   * @param {ServerAddress} address the address of the server to purge its pool.\n   * @returns {Promise<void>} A promise that is resolved when the resources are purged\n   */\n\n\n  Pool.prototype.purge = function (address) {\n    return this._purgeKey(address.asKey());\n  };\n  /**\n   * Destroy all idle resources in this pool.\n   * @returns {Promise<void>} A promise that is resolved when the resources are purged\n   */\n\n\n  Pool.prototype.close = function () {\n    var _this = this;\n\n    this._closed = true;\n    return Promise.all(Object.keys(this._pools).map(function (key) {\n      return _this._purgeKey(key);\n    }));\n  };\n  /**\n   * Keep the idle resources for the provided addresses and purge the rest.\n   * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n   */\n\n\n  Pool.prototype.keepAll = function (addresses) {\n    var _this = this;\n\n    var keysToKeep = addresses.map(function (a) {\n      return a.asKey();\n    });\n    var keysPresent = Object.keys(this._pools);\n    var keysToPurge = keysPresent.filter(function (k) {\n      return keysToKeep.indexOf(k) === -1;\n    });\n    return Promise.all(keysToPurge.map(function (key) {\n      return _this._purgeKey(key);\n    }));\n  };\n  /**\n   * Check if this pool contains resources for the given address.\n   * @param {ServerAddress} address the address of the server to check.\n   * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n   */\n\n\n  Pool.prototype.has = function (address) {\n    return address.asKey() in this._pools;\n  };\n  /**\n   * Get count of active (checked out of the pool) resources for the given key.\n   * @param {ServerAddress} address the address of the server to check.\n   * @return {number} count of resources acquired by clients.\n   */\n\n\n  Pool.prototype.activeResourceCount = function (address) {\n    return this._activeResourceCounts[address.asKey()] || 0;\n  };\n\n  Pool.prototype._acquire = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, pool, resource_1, numConnections, resource;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._closed) {\n              throw neo4j_driver_core_1.newError('Pool is closed, it is no more able to serve requests.');\n            }\n\n            key = address.asKey();\n            pool = this._pools[key];\n\n            if (!pool) {\n              pool = [];\n              this._pools[key] = pool;\n              this._pendingCreates[key] = 0;\n            }\n\n            _a.label = 1;\n\n          case 1:\n            if (!pool.length) return [3\n            /*break*/\n            , 5];\n            resource_1 = pool.pop();\n            if (!this._validate(resource_1)) return [3\n            /*break*/\n            , 2];\n\n            if (this._removeIdleObserver) {\n              this._removeIdleObserver(resource_1);\n            } // idle resource is valid and can be acquired\n\n\n            resourceAcquired(key, this._activeResourceCounts);\n\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource_1 + \" acquired from the pool \" + key);\n            }\n\n            return [2\n            /*return*/\n            , resource_1];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this._destroy(resource_1)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [3\n            /*break*/\n            , 1];\n\n          case 5:\n            // Ensure requested max pool size\n            if (this._maxSize > 0) {\n              numConnections = this.activeResourceCount(address) + this._pendingCreates[key];\n\n              if (numConnections >= this._maxSize) {\n                // Will put this request in queue instead since the pool is full\n                return [2\n                /*return*/\n                , null];\n              }\n            } // there exist no idle valid resources, create a new one for acquisition\n            // Keep track of how many pending creates there are to avoid making too many connections.\n\n\n            this._pendingCreates[key] = this._pendingCreates[key] + 1;\n            _a.label = 6;\n\n          case 6:\n            _a.trys.push([6,, 8, 9]);\n\n            return [4\n            /*yield*/\n            , this._create(address, this._release)];\n\n          case 7:\n            // Invoke callback that creates actual connection\n            resource = _a.sent();\n            resourceAcquired(key, this._activeResourceCounts);\n\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" created for the pool \" + key);\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            this._pendingCreates[key] = this._pendingCreates[key] - 1;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [2\n            /*return*/\n            , resource];\n        }\n      });\n    });\n  };\n\n  Pool.prototype._release = function (address, resource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, pool;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = address.asKey();\n            pool = this._pools[key];\n            if (!pool) return [3\n            /*break*/\n            , 4];\n            if (!!this._validate(resource)) return [3\n            /*break*/\n            , 2];\n\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because it is not functional\");\n            }\n\n            return [4\n            /*yield*/\n            , this._destroy(resource)];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (this._installIdleObserver) {\n              this._installIdleObserver(resource, {\n                onError: function (error) {\n                  _this._log.debug(\"Idle connection \" + resource + \" destroyed because of error: \" + error);\n\n                  var pool = _this._pools[key];\n\n                  if (pool) {\n                    _this._pools[key] = pool.filter(function (r) {\n                      return r !== resource;\n                    });\n                  } // let's not care about background clean-ups due to errors but just trigger the destroy\n                  // process for the resource, we especially catch any errors and ignore them to avoid\n                  // unhandled promise rejection warnings\n\n\n                  _this._destroy(resource).catch(function () {});\n                }\n              });\n            }\n\n            pool.push(resource);\n\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" released to the pool \" + key);\n            }\n\n            _a.label = 3;\n\n          case 3:\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            // key has been purged, don't put it back, just destroy the resource\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because pool has been purged\");\n            }\n\n            return [4\n            /*yield*/\n            , this._destroy(resource)];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            resourceReleased(key, this._activeResourceCounts);\n\n            this._processPendingAcquireRequests(address);\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Pool.prototype._purgeKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var pool, resource;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            pool = this._pools[key] || [];\n            _a.label = 1;\n\n          case 1:\n            if (!pool.length) return [3\n            /*break*/\n            , 3];\n            resource = pool.pop();\n\n            if (this._removeIdleObserver) {\n              this._removeIdleObserver(resource);\n            }\n\n            return [4\n            /*yield*/\n            , this._destroy(resource)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 1];\n\n          case 3:\n            delete this._pools[key];\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Pool.prototype._processPendingAcquireRequests = function (address) {\n    var _this = this;\n\n    var key = address.asKey();\n    var requests = this._acquireRequests[key];\n\n    if (requests) {\n      var pendingRequest_1 = requests.shift(); // pop a pending acquire request\n\n      if (pendingRequest_1) {\n        this._acquire(address).catch(function (error) {\n          // failed to acquire/create a new connection to resolve the pending acquire request\n          // propagate the error by failing the pending request\n          pendingRequest_1.reject(error);\n          return null;\n        }).then(function (resource) {\n          if (resource) {\n            // managed to acquire a valid resource from the pool\n            if (pendingRequest_1.isCompleted()) {\n              // request has been completed, most likely failed by a timeout\n              // return the acquired resource back to the pool\n              _this._release(address, resource);\n            } else {\n              // request is still pending and can be resolved with the newly acquired resource\n              pendingRequest_1.resolve(resource); // resolve the pending request with the acquired resource\n            }\n          }\n        });\n      } else {\n        delete this._acquireRequests[key];\n      }\n    }\n  };\n\n  return Pool;\n}();\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceAcquired(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceReleased(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  var nextCount = currentCount - 1;\n\n  if (nextCount > 0) {\n    activeResourceCounts[key] = nextCount;\n  } else {\n    delete activeResourceCounts[key];\n  }\n}\n\nvar PendingRequest =\n/** @class */\nfunction () {\n  function PendingRequest(key, resolve, reject, timeoutId, log) {\n    this._key = key;\n    this._resolve = resolve;\n    this._reject = reject;\n    this._timeoutId = timeoutId;\n    this._log = log;\n    this._completed = false;\n  }\n\n  PendingRequest.prototype.isCompleted = function () {\n    return this._completed;\n  };\n\n  PendingRequest.prototype.resolve = function (resource) {\n    if (this._completed) {\n      return;\n    }\n\n    this._completed = true;\n    clearTimeout(this._timeoutId);\n\n    if (this._log.isDebugEnabled()) {\n      this._log.debug(resource + \" acquired from the pool \" + this._key);\n    }\n\n    this._resolve(resource);\n  };\n\n  PendingRequest.prototype.reject = function (error) {\n    if (this._completed) {\n      return;\n    }\n\n    this._completed = true;\n    clearTimeout(this._timeoutId);\n\n    this._reject(error);\n  };\n\n  return PendingRequest;\n}();\n\nexports.default = Pool;","map":{"version":3,"sources":["/Users/ericyangchen/Downloads/Ont/frontend/node_modules/neo4j-driver-bolt-connection/lib/pool/pool.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__importDefault","mod","__esModule","Object","defineProperty","exports","pool_config_1","require","neo4j_driver_core_1","Logger","internal","logger","Pool","_a","_b","_c","create","address","release","_d","destroy","conn","_e","validate","_f","installIdleObserver","observer","_g","removeIdleObserver","_h","config","default","defaultConfig","_j","log","noOp","_create","_destroy","_validate","_installIdleObserver","_removeIdleObserver","_maxSize","maxSize","_acquisitionTimeout","acquisitionTimeout","_pools","_pendingCreates","_acquireRequests","_activeResourceCounts","_release","bind","_log","_closed","prototype","acquire","_this","_acquire","resource","key","asKey","allRequests","requests","request","timeoutId","setTimeout","pendingRequests","filter","item","isCompleted","activeCount","activeResourceCount","idleCount","has","newError","PendingRequest","purge","_purgeKey","close","all","keys","map","keepAll","addresses","keysToKeep","a","keysPresent","keysToPurge","k","indexOf","pool","resource_1","numConnections","resourceAcquired","isDebugEnabled","debug","onError","error","r","catch","resourceReleased","_processPendingAcquireRequests","pendingRequest_1","shift","activeResourceCounts","currentCount","nextCount","_key","_resolve","_reject","_timeoutId","_completed","clearTimeout"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pool_config_1 = __importDefault(require(\"./pool-config\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar Logger = neo4j_driver_core_1.internal.logger.Logger;\nvar Pool = /** @class */ (function () {\n    /**\n     * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n     *                an allocation function that creates a promise with a new resource. It's given an address for which to\n     *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n     *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n     * @param {function(resource: object): Promise<void>} destroy\n     *                called with the resource when it is evicted from this pool\n     * @param {function(resource: object): boolean} validate\n     *                called at various times (like when an instance is acquired and when it is returned.\n     *                If this returns false, the resource will be evicted\n     * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n     *                called when the resource is released back to pool\n     * @param {function(resource: object): void} removeIdleObserver\n     *                called when the resource is acquired from the pool\n     * @param {PoolConfig} config configuration for the new driver.\n     * @param {Logger} log the driver logger.\n     */\n    function Pool(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.create, create = _c === void 0 ? function (address, release) { return Promise.resolve(); } : _c, _d = _b.destroy, destroy = _d === void 0 ? function (conn) { return Promise.resolve(); } : _d, _e = _b.validate, validate = _e === void 0 ? function (conn) { return true; } : _e, _f = _b.installIdleObserver, installIdleObserver = _f === void 0 ? function (conn, observer) { } : _f, _g = _b.removeIdleObserver, removeIdleObserver = _g === void 0 ? function (conn) { } : _g, _h = _b.config, config = _h === void 0 ? pool_config_1.default.defaultConfig() : _h, _j = _b.log, log = _j === void 0 ? Logger.noOp() : _j;\n        this._create = create;\n        this._destroy = destroy;\n        this._validate = validate;\n        this._installIdleObserver = installIdleObserver;\n        this._removeIdleObserver = removeIdleObserver;\n        this._maxSize = config.maxSize;\n        this._acquisitionTimeout = config.acquisitionTimeout;\n        this._pools = {};\n        this._pendingCreates = {};\n        this._acquireRequests = {};\n        this._activeResourceCounts = {};\n        this._release = this._release.bind(this);\n        this._log = log;\n        this._closed = false;\n    }\n    /**\n     * Acquire and idle resource fom the pool or create a new one.\n     * @param {ServerAddress} address the address for which we're acquiring.\n     * @return {Object} resource that is ready to use.\n     */\n    Pool.prototype.acquire = function (address) {\n        var _this = this;\n        return this._acquire(address).then(function (resource) {\n            var key = address.asKey();\n            if (resource) {\n                // New or existing resource acquired\n                return resource;\n            }\n            // We're out of resources and will try to acquire later on when an existing resource is released.\n            var allRequests = _this._acquireRequests;\n            var requests = allRequests[key];\n            if (!requests) {\n                allRequests[key] = [];\n            }\n            return new Promise(function (resolve, reject) {\n                var request;\n                var timeoutId = setTimeout(function () {\n                    // acquisition timeout fired\n                    // remove request from the queue of pending requests, if it's still there\n                    // request might've been taken out by the release operation\n                    var pendingRequests = allRequests[key];\n                    if (pendingRequests) {\n                        allRequests[key] = pendingRequests.filter(function (item) { return item !== request; });\n                    }\n                    if (request.isCompleted()) {\n                        // request already resolved/rejected by the release operation; nothing to do\n                    }\n                    else {\n                        // request is still pending and needs to be failed\n                        var activeCount = _this.activeResourceCount(address);\n                        var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n                        request.reject(neo4j_driver_core_1.newError(\"Connection acquisition timed out in \" + _this._acquisitionTimeout + \" ms. Poos status: Active conn count = \" + activeCount + \", Idle conn count = \" + idleCount + \".\"));\n                    }\n                }, _this._acquisitionTimeout);\n                request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n                allRequests[key].push(request);\n            });\n        });\n    };\n    /**\n     * Destroy all idle resources for the given address.\n     * @param {ServerAddress} address the address of the server to purge its pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n    Pool.prototype.purge = function (address) {\n        return this._purgeKey(address.asKey());\n    };\n    /**\n     * Destroy all idle resources in this pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n    Pool.prototype.close = function () {\n        var _this = this;\n        this._closed = true;\n        return Promise.all(Object.keys(this._pools).map(function (key) { return _this._purgeKey(key); }));\n    };\n    /**\n     * Keep the idle resources for the provided addresses and purge the rest.\n     * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n     */\n    Pool.prototype.keepAll = function (addresses) {\n        var _this = this;\n        var keysToKeep = addresses.map(function (a) { return a.asKey(); });\n        var keysPresent = Object.keys(this._pools);\n        var keysToPurge = keysPresent.filter(function (k) { return keysToKeep.indexOf(k) === -1; });\n        return Promise.all(keysToPurge.map(function (key) { return _this._purgeKey(key); }));\n    };\n    /**\n     * Check if this pool contains resources for the given address.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n     */\n    Pool.prototype.has = function (address) {\n        return address.asKey() in this._pools;\n    };\n    /**\n     * Get count of active (checked out of the pool) resources for the given key.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {number} count of resources acquired by clients.\n     */\n    Pool.prototype.activeResourceCount = function (address) {\n        return this._activeResourceCounts[address.asKey()] || 0;\n    };\n    Pool.prototype._acquire = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key, pool, resource_1, numConnections, resource;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this._closed) {\n                            throw neo4j_driver_core_1.newError('Pool is closed, it is no more able to serve requests.');\n                        }\n                        key = address.asKey();\n                        pool = this._pools[key];\n                        if (!pool) {\n                            pool = [];\n                            this._pools[key] = pool;\n                            this._pendingCreates[key] = 0;\n                        }\n                        _a.label = 1;\n                    case 1:\n                        if (!pool.length) return [3 /*break*/, 5];\n                        resource_1 = pool.pop();\n                        if (!this._validate(resource_1)) return [3 /*break*/, 2];\n                        if (this._removeIdleObserver) {\n                            this._removeIdleObserver(resource_1);\n                        }\n                        // idle resource is valid and can be acquired\n                        resourceAcquired(key, this._activeResourceCounts);\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(resource_1 + \" acquired from the pool \" + key);\n                        }\n                        return [2 /*return*/, resource_1];\n                    case 2: return [4 /*yield*/, this._destroy(resource_1)];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [3 /*break*/, 1];\n                    case 5:\n                        // Ensure requested max pool size\n                        if (this._maxSize > 0) {\n                            numConnections = this.activeResourceCount(address) + this._pendingCreates[key];\n                            if (numConnections >= this._maxSize) {\n                                // Will put this request in queue instead since the pool is full\n                                return [2 /*return*/, null];\n                            }\n                        }\n                        // there exist no idle valid resources, create a new one for acquisition\n                        // Keep track of how many pending creates there are to avoid making too many connections.\n                        this._pendingCreates[key] = this._pendingCreates[key] + 1;\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, , 8, 9]);\n                        return [4 /*yield*/, this._create(address, this._release)];\n                    case 7:\n                        // Invoke callback that creates actual connection\n                        resource = _a.sent();\n                        resourceAcquired(key, this._activeResourceCounts);\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(resource + \" created for the pool \" + key);\n                        }\n                        return [3 /*break*/, 9];\n                    case 8:\n                        this._pendingCreates[key] = this._pendingCreates[key] - 1;\n                        return [7 /*endfinally*/];\n                    case 9: return [2 /*return*/, resource];\n                }\n            });\n        });\n    };\n    Pool.prototype._release = function (address, resource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key, pool;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        key = address.asKey();\n                        pool = this._pools[key];\n                        if (!pool) return [3 /*break*/, 4];\n                        if (!!this._validate(resource)) return [3 /*break*/, 2];\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because it is not functional\");\n                        }\n                        return [4 /*yield*/, this._destroy(resource)];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (this._installIdleObserver) {\n                            this._installIdleObserver(resource, {\n                                onError: function (error) {\n                                    _this._log.debug(\"Idle connection \" + resource + \" destroyed because of error: \" + error);\n                                    var pool = _this._pools[key];\n                                    if (pool) {\n                                        _this._pools[key] = pool.filter(function (r) { return r !== resource; });\n                                    }\n                                    // let's not care about background clean-ups due to errors but just trigger the destroy\n                                    // process for the resource, we especially catch any errors and ignore them to avoid\n                                    // unhandled promise rejection warnings\n                                    _this._destroy(resource).catch(function () { });\n                                }\n                            });\n                        }\n                        pool.push(resource);\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(resource + \" released to the pool \" + key);\n                        }\n                        _a.label = 3;\n                    case 3: return [3 /*break*/, 6];\n                    case 4:\n                        // key has been purged, don't put it back, just destroy the resource\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because pool has been purged\");\n                        }\n                        return [4 /*yield*/, this._destroy(resource)];\n                    case 5:\n                        _a.sent();\n                        _a.label = 6;\n                    case 6:\n                        resourceReleased(key, this._activeResourceCounts);\n                        this._processPendingAcquireRequests(address);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Pool.prototype._purgeKey = function (key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var pool, resource;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        pool = this._pools[key] || [];\n                        _a.label = 1;\n                    case 1:\n                        if (!pool.length) return [3 /*break*/, 3];\n                        resource = pool.pop();\n                        if (this._removeIdleObserver) {\n                            this._removeIdleObserver(resource);\n                        }\n                        return [4 /*yield*/, this._destroy(resource)];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 1];\n                    case 3:\n                        delete this._pools[key];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Pool.prototype._processPendingAcquireRequests = function (address) {\n        var _this = this;\n        var key = address.asKey();\n        var requests = this._acquireRequests[key];\n        if (requests) {\n            var pendingRequest_1 = requests.shift(); // pop a pending acquire request\n            if (pendingRequest_1) {\n                this._acquire(address)\n                    .catch(function (error) {\n                    // failed to acquire/create a new connection to resolve the pending acquire request\n                    // propagate the error by failing the pending request\n                    pendingRequest_1.reject(error);\n                    return null;\n                })\n                    .then(function (resource) {\n                    if (resource) {\n                        // managed to acquire a valid resource from the pool\n                        if (pendingRequest_1.isCompleted()) {\n                            // request has been completed, most likely failed by a timeout\n                            // return the acquired resource back to the pool\n                            _this._release(address, resource);\n                        }\n                        else {\n                            // request is still pending and can be resolved with the newly acquired resource\n                            pendingRequest_1.resolve(resource); // resolve the pending request with the acquired resource\n                        }\n                    }\n                });\n            }\n            else {\n                delete this._acquireRequests[key];\n            }\n        }\n    };\n    return Pool;\n}());\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceAcquired(key, activeResourceCounts) {\n    var currentCount = activeResourceCounts[key] || 0;\n    activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceReleased(key, activeResourceCounts) {\n    var currentCount = activeResourceCounts[key] || 0;\n    var nextCount = currentCount - 1;\n    if (nextCount > 0) {\n        activeResourceCounts[key] = nextCount;\n    }\n    else {\n        delete activeResourceCounts[key];\n    }\n}\nvar PendingRequest = /** @class */ (function () {\n    function PendingRequest(key, resolve, reject, timeoutId, log) {\n        this._key = key;\n        this._resolve = resolve;\n        this._reject = reject;\n        this._timeoutId = timeoutId;\n        this._log = log;\n        this._completed = false;\n    }\n    PendingRequest.prototype.isCompleted = function () {\n        return this._completed;\n    };\n    PendingRequest.prototype.resolve = function (resource) {\n        if (this._completed) {\n            return;\n        }\n        this._completed = true;\n        clearTimeout(this._timeoutId);\n        if (this._log.isDebugEnabled()) {\n            this._log.debug(resource + \" acquired from the pool \" + this._key);\n        }\n        this._resolve(resource);\n    };\n    PendingRequest.prototype.reject = function (error) {\n        if (this._completed) {\n            return;\n        }\n        this._completed = true;\n        clearTimeout(this._timeoutId);\n        this._reject(error);\n    };\n    return PendingRequest;\n}());\nexports.default = Pool;\n"]},"metadata":{},"sourceType":"script"}